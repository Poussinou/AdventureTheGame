var busy = TRUE;
var hideInventory = TRUE;

sub go () {
	onLeftMouse (leftClick);
	onRightMouse (dropObj);
	busy = FALSE;
	onFocusChange (handleFocus);

	# We haven't been updating, so let's do this ourselves
	handleFocus (getOverObject ());
}

sub dropObj () {
	currentInvItem = NULL;
	handleFocus (getOverObject ());
}

sub stop () {
	onFocusChange ();
	statusText ("");
	onLeftMouse ();
	onRightMouse (skipper);
	setCursor (anim ('iface/mouse.duc', wait(4, 10), wait(3, 10), wait(2, 10)));
	busy = TRUE;
}

sub skipper () {
	skipSpeech ();
}

sub unfreezer(key) {
	if (key == "ESCAPE") {
		unfreeze();
	}
}

sub handleFocus (o) {
	if (o && (o != ego || currentInvItem != NULL)) {
		if (! currentInvItem) {
			if (! callEvent (oneCursor, o)) setCursor (anim ('iface/mouse.duc', 6));
		} else {
			setCursor (anim ('iface/mouse.duc', wait(6, 5), wait(5, 5)));
		}
	} else {
		if (! currentInvItem) {
			setCursor (anim ('iface/mouse.duc', 7));
		} else {
			callEvent (getIcon, currentInvItem);
                        setCursor(icon);
		}
	}
	drawStatusLine (o);
}

sub drawStatusLine (overObject) {
	if (! busy) {
		if (currentInvItem) {
			if (overObject && overObject != currentInvItem) {
				statusText ("Use " + currentInvItem + " with " + overObject);
			} else {
				statusText ("Use " + currentInvItem + " with");
			}
		} else {
			statusText ((overObject && overObject != ego && currentInvItem == NULL ? overObject : "") + ((overObject != cancel && overObject != useInventory) ? (thisObject ? thisObject : "") : ""));
		}
	}
}

# Fading scripts
sub fadeIn()
{
	transitionMode(FADE);
	for(var a = 0; a < 256; a += 10)
	{
		transitionLevel(a);
		pause(1);
	}
	transitionLevel(255);
}

sub fadeOut()
{
	transitionMode(FADE);
	for(var a = 255; a > 0; a -= 10)
	{
		transitionLevel(a);
		pause(1);
	}
	transitionLevel(0);
}

sub smoothScroll(startX, x)
{
	var camX = startX;
	
	while((x > startX) ? (camX < x) : (camX > x))
	{
		camX += (x - startX) / 45;
		aimCamera(camX, 384);
		pause(1);
	}
}

sub countItems(it)
{
	var count = 0;
	
	for(var i = 0; i < stackSize(inventory); i++)
		if(inventory[i] == it)
			count++;
	
	return count;
}

sub narratorSay(text)
{
	freeze();
	onRightMouse(skipper);
	onKeyboard(keys);
	darkBackground();
	addScreenRegion(narrator, 683, 384, 684, 385, 0, 0, 0);
	say(narrator, text);
	removeScreenRegion(narrator);
	unfreeze();
}

objectType narrator("")
{
	speechColor 255, 255, 255;
}

#var currentRoom = NULL;
#var lastRoom = NULL;

sub gotoRoom (r) {
	# Get rid of all the object types
	removeAllCharacters ();
	removeAllScreenRegions ();

	# Get rid of the floor and z-buffer, in case the new room forgets to load any
	setFloor (NULL);
	setZBuffer (NULL);
	
	# Finish any running timers we might have on the go
	completeTimers ();

	# Fix the variables lastRoom and currentRoom
	# (We don't NEED them, but they are useful in scripts)
	#lastRoom = currentRoom;
	#currentRoom = r;

	addCharacter (inventoryIcon, -20, -755, anim ('iface/mouse.duc', 5)); # lazy way to hide it
	setCharacterExtra (inventoryIcon, ICON);
	
	if(hideInventory)
	{
		hideCharacter(inventoryIcon);
	}

	# Now, finally call the function to build the new room
	r ();
}

sub pauseGame() {
	freeze();
	darkBackground();
	setPasteColor(255,255,255);
	pasteString(CENTER, 768/2 - 10, "Game paused");
	onKeyboard(unpauseGame);
}

sub unpauseGame(key) {
	unfreeze();
	onKeyboard(keys);
	key; # supress warning, key is unused intentionally
}

sub doYouReallyWantToQuit() {
	freeze();
	darkBackground();
	setPasteColor(255,255,255);
	pasteString(CENTER, 768/2 - 30, "Do you really want to quit? Y/N");
	setPasteColor(180, 180, 180);
	pasteString(CENTER, 768/2 + 30, "Your game will be autosaved. You can press A to load it later.");
	onKeyboard(wantToQuitHandler);
}
	
sub wantToQuitHandler(key) {
	if (key == "y") {
		while (howFrozen() > 0) {
			unfreeze();
		}
		if (saveGame("auto")) {
			quitGame ();
		}
	}
	if (key == "n" || key == "ESCAPE") {
		unfreeze();
	}
}
